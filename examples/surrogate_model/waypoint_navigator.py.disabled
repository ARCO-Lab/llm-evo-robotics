#!/usr/bin/env python3
"""
è·¯æ ‡ç‚¹å¯¼èˆªç³»ç»Ÿ
å®ç°æ™ºèƒ½è·¯æ ‡ç‚¹å¯¼èˆªï¼Œæå‡æœºå™¨äººå­¦ä¹ æ•ˆç‡
"""

import numpy as np
import math
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class Waypoint:
    """è·¯æ ‡ç‚¹æ•°æ®ç»“æ„"""
    position: np.ndarray
    radius: float = 30.0  # åˆ°è¾¾åˆ¤å®šåŠå¾„
    reward: float = 10.0  # åˆ°è¾¾å¥–åŠ±
    visited: bool = False
    visit_time: Optional[int] = None

class WaypointNavigator:
    """è·¯æ ‡ç‚¹å¯¼èˆªå™¨"""
    
    def __init__(self, start_pos: np.ndarray, goal_pos: np.ndarray, obstacles: List = None):
        """
        åˆå§‹åŒ–è·¯æ ‡ç‚¹å¯¼èˆªå™¨
        
        Args:
            start_pos: èµ·ç‚¹ä½ç½®
            goal_pos: ç»ˆç‚¹ä½ç½®  
            obstacles: éšœç¢ç‰©åˆ—è¡¨ï¼ˆå¯é€‰ï¼‰
        """
        self.start_pos = np.array(start_pos)
        self.goal_pos = np.array(goal_pos)
        self.obstacles = obstacles or []
        
        # è·¯æ ‡ç‚¹ç³»ç»ŸçŠ¶æ€
        self.waypoints: List[Waypoint] = []
        self.current_waypoint_idx = 0
        self.total_reward = 0.0
        self.step_count = 0
        self.completion_bonus = 50.0
        
        # ç”Ÿæˆè·¯æ ‡ç‚¹
        self._generate_waypoints()
        
        print(f"ğŸ—ºï¸ WaypointNavigator åˆå§‹åŒ–å®Œæˆ")
        print(f"   èµ·ç‚¹: {self.start_pos}")
        print(f"   ç»ˆç‚¹: {self.goal_pos}")
        print(f"   æ€»è·¯æ ‡æ•°: {len(self.waypoints)}")
    
    def _generate_waypoints(self):
        """ç”Ÿæˆè·¯æ ‡ç‚¹è·¯å¾„"""
        
        # ç­–ç•¥ï¼šç»•è¡Œè·¯å¾„ï¼ˆé¿å¼€éšœç¢ç‰©ï¼‰
        waypoint_positions = self._calculate_bypass_path()
        
        # åˆ›å»ºè·¯æ ‡ç‚¹å¯¹è±¡
        for i, pos in enumerate(waypoint_positions):
            # æœ€åä¸€ä¸ªæ˜¯ç»ˆç‚¹ï¼Œå¥–åŠ±æ›´é«˜
            reward = self.completion_bonus if i == len(waypoint_positions) - 1 else 10.0
            radius = 35.0 if i == len(waypoint_positions) - 1 else 30.0
            
            waypoint = Waypoint(
                position=np.array(pos),
                radius=radius,
                reward=reward,
                visited=False
            )
            self.waypoints.append(waypoint)
            
            print(f"   è·¯æ ‡{i}: {pos} (åŠå¾„:{radius}, å¥–åŠ±:{reward})")
    
    def _calculate_bypass_path(self) -> List[Tuple[float, float]]:
        """è®¡ç®—ç»•è¡Œè·¯å¾„"""
        
        # åŸºäºå½“å‰é…ç½®çš„ä¼˜åŒ–è·¯å¾„
        # èµ·ç‚¹: [500, 620], ç»ˆç‚¹: [600, 550]
        
        path = [
            tuple(self.start_pos),           # èµ·ç‚¹
            (450, 620),                      # å·¦ç§»ï¼Œè¿œç¦»éšœç¢ç‰©
            (450, 550),                      # ä¸Šç§»åˆ°ç›®æ ‡Yåæ ‡
            (550, 550),                      # å³ç§»ï¼Œæ¥è¿‘ç›®æ ‡Xåæ ‡
            tuple(self.goal_pos),            # ç»ˆç‚¹
        ]
        
        # å¯é€‰ï¼šä½¿ç”¨A*ç®—æ³•ä¼˜åŒ–è·¯å¾„
        # path = self._astar_path_planning()
        
        return path
    
    def _astar_path_planning(self) -> List[Tuple[float, float]]:
        """A*è·¯å¾„è§„åˆ’ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        
        # è¿™é‡Œå¯ä»¥å®ç°å®Œæ•´çš„A*ç®—æ³•
        # å½“å‰ä½¿ç”¨ç®€åŒ–çš„ç›´æ¥è·¯å¾„è§„åˆ’
        
        # å°†è·¯å¾„åˆ†æˆå¤šä¸ªå°æ®µ
        num_segments = 4
        path = []
        
        for i in range(num_segments + 1):
            t = i / num_segments
            # çº¿æ€§æ’å€¼
            x = self.start_pos[0] + t * (self.goal_pos[0] - self.start_pos[0])
            y = self.start_pos[1] + t * (self.goal_pos[1] - self.start_pos[1])
            
            # é¿éšœè°ƒæ•´
            if self._is_near_obstacles([x, y]):
                x -= 50  # å‘å·¦åç§»é¿å¼€éšœç¢ç‰©
            
            path.append((x, y))
        
        return path
    
    def _is_near_obstacles(self, pos: List[float], safe_distance: float = 50.0) -> bool:
        """æ£€æŸ¥ä½ç½®æ˜¯å¦é è¿‘éšœç¢ç‰©"""
        
        # ç®€åŒ–çš„éšœç¢ç‰©æ£€æµ‹
        # åŸºäºé…ç½®æ–‡ä»¶ä¸­çš„é”¯é½¿å½¢éšœç¢ç‰©
        obstacle_zones = [
            {"center": [575, 525], "radius": 100},  # é”¯é½¿å½¢éšœç¢ç‰©åŒºåŸŸ
            {"center": [575, 625], "radius": 100},
        ]
        
        for zone in obstacle_zones:
            distance = np.linalg.norm(np.array(pos) - np.array(zone["center"]))
            if distance < zone["radius"] + safe_distance:
                return True
        
        return False
    
    def get_current_target(self) -> np.ndarray:
        """è·å–å½“å‰ç›®æ ‡ä½ç½®"""
        if self.current_waypoint_idx < len(self.waypoints):
            return self.waypoints[self.current_waypoint_idx].position
        return self.goal_pos
    
    def update(self, current_pos: np.ndarray) -> Tuple[float, dict]:
        """
        æ›´æ–°å¯¼èˆªçŠ¶æ€å¹¶è®¡ç®—å¥–åŠ±
        
        Args:
            current_pos: å½“å‰ä½ç½®
            
        Returns:
            (reward, info): å¥–åŠ±å€¼å’Œä¿¡æ¯å­—å…¸
        """
        self.step_count += 1
        total_reward = 0.0
        info = {
            "waypoint_reached": False,
            "current_waypoint": self.current_waypoint_idx,
            "total_waypoints": len(self.waypoints),
            "completion_progress": 0.0,
            "waypoint_reward": 0.0,
            "distance_to_waypoint": 0.0,
        }
        
        if self.current_waypoint_idx >= len(self.waypoints):
            # æ‰€æœ‰è·¯æ ‡ç‚¹å·²å®Œæˆ
            info["completion_progress"] = 1.0
            return 0.0, info
        
        current_waypoint = self.waypoints[self.current_waypoint_idx]
        distance_to_waypoint = np.linalg.norm(current_pos - current_waypoint.position)
        info["distance_to_waypoint"] = distance_to_waypoint
        
        # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å½“å‰è·¯æ ‡ç‚¹
        if distance_to_waypoint <= current_waypoint.radius and not current_waypoint.visited:
            # åˆ°è¾¾è·¯æ ‡ç‚¹ï¼
            current_waypoint.visited = True
            current_waypoint.visit_time = self.step_count
            
            waypoint_reward = current_waypoint.reward
            total_reward += waypoint_reward
            self.total_reward += waypoint_reward
            
            info["waypoint_reached"] = True
            info["waypoint_reward"] = waypoint_reward
            
            print(f"ğŸ¯ åˆ°è¾¾è·¯æ ‡ç‚¹ {self.current_waypoint_idx}! ä½ç½®: {current_waypoint.position}, å¥–åŠ±: +{waypoint_reward}")
            
            # åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªè·¯æ ‡ç‚¹
            self.current_waypoint_idx += 1
            
            if self.current_waypoint_idx >= len(self.waypoints):
                print(f"ğŸ† æ‰€æœ‰è·¯æ ‡ç‚¹å®Œæˆ! æ€»å¥–åŠ±: {self.total_reward}")
                info["completion_progress"] = 1.0
        
        # è®¡ç®—è¿›åº¦
        info["completion_progress"] = self.current_waypoint_idx / len(self.waypoints)
        
        # è·ç¦»å¥–åŠ±ï¼ˆæ¥è¿‘å½“å‰è·¯æ ‡ç‚¹ï¼‰
        if self.current_waypoint_idx < len(self.waypoints):
            # ç»™äºˆæ¥è¿‘å½“å‰è·¯æ ‡ç‚¹çš„å°å¹…å¥–åŠ±
            max_distance = 200.0  # æœ€å¤§æœ‰æ•ˆè·ç¦»
            approach_reward = max(0, (max_distance - distance_to_waypoint) / max_distance * 0.5)
            total_reward += approach_reward
        
        return total_reward, info
    
    def reset(self):
        """é‡ç½®å¯¼èˆªå™¨çŠ¶æ€"""
        self.current_waypoint_idx = 0
        self.total_reward = 0.0
        self.step_count = 0
        
        for waypoint in self.waypoints:
            waypoint.visited = False
            waypoint.visit_time = None
        
        print(f"ğŸ”„ WaypointNavigator å·²é‡ç½®")
    
    def get_progress_info(self) -> dict:
        """è·å–è¿›åº¦ä¿¡æ¯"""
        completed = sum(1 for wp in self.waypoints if wp.visited)
        total = len(self.waypoints)
        
        return {
            "completed_waypoints": completed,
            "total_waypoints": total,
            "progress_percentage": (completed / total) * 100.0,
            "current_target": self.get_current_target().tolist(),
            "total_reward_earned": self.total_reward,
        }
    
    def visualize_path(self, save_path: str = None):
        """å¯è§†åŒ–è·¯å¾„ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰"""
        try:
            import matplotlib.pyplot as plt
            
            fig, ax = plt.subplots(figsize=(10, 8))
            
            # ç»˜åˆ¶è·¯æ ‡ç‚¹
            for i, wp in enumerate(self.waypoints):
                color = 'green' if wp.visited else 'blue'
                marker = 'o' if i < len(self.waypoints) - 1 else 's'  # æœ€åä¸€ä¸ªç”¨æ–¹å½¢
                
                ax.scatter(wp.position[0], wp.position[1], 
                          c=color, s=100, marker=marker, alpha=0.7)
                ax.annotate(f'W{i}', (wp.position[0], wp.position[1]), 
                           xytext=(5, 5), textcoords='offset points')
                
                # ç»˜åˆ¶åˆ°è¾¾åŠå¾„
                circle = plt.Circle(wp.position, wp.radius, fill=False, alpha=0.3)
                ax.add_patch(circle)
            
            # ç»˜åˆ¶è·¯å¾„è¿çº¿
            positions = [wp.position for wp in self.waypoints]
            x_coords = [pos[0] for pos in positions]
            y_coords = [pos[1] for pos in positions]
            ax.plot(x_coords, y_coords, 'b--', alpha=0.5, linewidth=2)
            
            # æ ‡è®°èµ·ç‚¹å’Œç»ˆç‚¹
            ax.scatter(self.start_pos[0], self.start_pos[1], 
                      c='red', s=150, marker='^', label='Start')
            ax.scatter(self.goal_pos[0], self.goal_pos[1], 
                      c='gold', s=150, marker='*', label='Goal')
            
            ax.set_xlabel('X Position')
            ax.set_ylabel('Y Position')
            ax.set_title('Waypoint Navigation Path')
            ax.legend()
            ax.grid(True, alpha=0.3)
            ax.set_aspect('equal')
            
            if save_path:
                plt.savefig(save_path, dpi=300, bbox_inches='tight')
                print(f"ğŸ“Š è·¯å¾„å›¾å·²ä¿å­˜åˆ°: {save_path}")
            else:
                plt.show()
                
        except ImportError:
            print("âš ï¸ matplotlibæœªå®‰è£…ï¼Œæ— æ³•å¯è§†åŒ–è·¯å¾„")

def test_waypoint_navigator():
    """æµ‹è¯•è·¯æ ‡ç‚¹å¯¼èˆªå™¨"""
    
    print("ğŸ§ª æµ‹è¯• WaypointNavigator")
    print("="*50)
    
    # ä½¿ç”¨å½“å‰é…ç½®
    start = [500, 620]
    goal = [600, 550]
    
    navigator = WaypointNavigator(start, goal)
    
    # æ¨¡æ‹Ÿæœºå™¨äººç§»åŠ¨
    current_pos = np.array(start, dtype=float)
    
    for step in range(50):
        # æ¨¡æ‹Ÿå‘å½“å‰ç›®æ ‡ç§»åŠ¨
        target = navigator.get_current_target()
        direction = target - current_pos
        distance = np.linalg.norm(direction)
        
        if distance > 0:
            # æ¯æ­¥ç§»åŠ¨10åƒç´ 
            move_distance = min(10.0, distance)
            current_pos += (direction / distance) * move_distance
        
        # æ›´æ–°å¯¼èˆªå™¨
        reward, info = navigator.update(current_pos)
        
        if step % 10 == 0 or info["waypoint_reached"]:
            print(f"æ­¥éª¤ {step}: ä½ç½® {current_pos.astype(int)}, "
                  f"ç›®æ ‡ {target.astype(int)}, å¥–åŠ± {reward:.2f}")
            
            if info["waypoint_reached"]:
                print(f"  ğŸ¯ åˆ°è¾¾è·¯æ ‡ç‚¹! è¿›åº¦: {info['completion_progress']*100:.1f}%")
        
        # æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if info["completion_progress"] >= 1.0:
            print(f"ğŸ† å¯¼èˆªå®Œæˆ! æ€»æ­¥æ•°: {step+1}")
            break
    
    # æ˜¾ç¤ºæœ€ç»ˆçŠ¶æ€
    progress = navigator.get_progress_info()
    print(f"\nğŸ“Š æœ€ç»ˆè¿›åº¦:")
    for key, value in progress.items():
        print(f"   {key}: {value}")

if __name__ == "__main__":
    test_waypoint_navigator()
