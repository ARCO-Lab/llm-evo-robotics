# import gymnasium as gym
# from gymnasium import Env
# from gymnasium.spaces import Box

import gym

from gym import Env

from gym.spaces import Box

from pymunk import Segment
import pymunk
import pymunk.pygame_util  # æ˜ç¡®å¯¼å…¥pygame_util
import numpy as np
import pygame
import math
import yaml

import os
import sys
base_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "../../..")
sys.path.append(base_dir)
sys.path.insert(0, os.path.join(base_dir, 'examples/2d_reacher'))
sys.path.insert(0, os.path.join(base_dir, 'examples/2d_reacher/envs'))
sys.path.insert(0, os.path.join(base_dir, 'examples/2d_reacher/configs'))
print(sys.path)

class Reacher2DEnv(Env):

    
    def __init__(self, num_links=3, link_lengths=None, render_mode=None, config_path=None):

        super().__init__()
        self.config = self._load_config(config_path)
        print(f"self.config: {self.config}")
        self.anchor_point = self.config["start"]["position"]
        self.gym_api_version = "old" # old or new. new is gymnasium, old is gym

        self.num_links = num_links  # ä¿®å¤ï¼šä½¿ç”¨ä¼ å…¥çš„å‚æ•°
        if link_lengths is None:

            self.link_lengths = [60] * num_links

        else:
            assert len(link_lengths) == num_links
            self.link_lengths = link_lengths
        
        self.render_mode = render_mode
        # self.goal_pos = np.array([250.0, 250.0])
        self.dt = 1/60.0  # å¢åŠ æ—¶é—´æ­¥é•¿ç²¾åº¦
        self.max_torque = 100  # å¢åŠ æœ€å¤§æ‰­çŸ©

        # å®šä¹‰Gymnasiumå¿…éœ€çš„action_spaceå’Œobservation_space
        self.action_space = Box(low=-self.max_torque, high=self.max_torque, shape=(self.num_links,), dtype=np.float32)
        # self.observation_space = Box(low=-np.inf, high=np.inf, shape=(self.num_links * 2 + 2,), dtype=np.float32)
        self.observation_space = Box(low=-np.inf, high=np.inf, shape=(self.num_links * 2 + 7,), dtype=np.float32)
        self.space = pymunk.Space()
        self.space.gravity = (0.0, 981.0)
        # å‡å°‘å…¨å±€é˜»å°¼
        self.space.damping = 0.999  # ğŸ”§ å¢åŠ é˜»å°¼è®©è§’åº¦é™åˆ¶æ›´æœ‰æ•ˆ
        self.obstacles = []
        self.bodies = []
        self.joints = []

        self._create_robot()  # ä¿®å¤ï¼šæ–¹æ³•åæ”¹ä¸º_create_robot
        self._create_obstacle()

        # åˆå§‹åŒ–æ¸²æŸ“ç›¸å…³å˜é‡
        self.screen = None
        self.clock = None
        self.draw_options = None

        if self.render_mode:
            self._init_rendering()

    def _init_rendering(self):
        """åˆå§‹åŒ–æ¸²æŸ“ç›¸å…³ç»„ä»¶"""
        pygame.init()
        self.screen = pygame.display.set_mode((1200, 1200))
        self.clock = pygame.time.Clock()
        self.draw_options = pymunk.pygame_util.DrawOptions(self.screen)

        

    def _create_robot(self):
        prev_body = None
        density = 0.8  # ğŸ”§ å¢åŠ å¯†åº¦ï¼Œè®©çº¦æŸæ›´ç¨³å®š
        self.joint_limits = []  # ğŸ”§ å­˜å‚¨è§’åº¦é™åˆ¶çº¦æŸ
        
        # ğŸ”§ å®šä¹‰å…³èŠ‚è§’åº¦é™åˆ¶èŒƒå›´ï¼ˆå¼§åº¦ï¼‰
        # æ›´ä¸¥æ ¼çš„è§’åº¦é™åˆ¶
        self.joint_angle_limits = [
            (-math.pi * 3/4, math.pi * 3/4),    # ç¬¬1ä¸ªå…³èŠ‚ï¼šÂ±135Â° (æ¯”ä¹‹å‰æ›´ä¸¥æ ¼)
            (-math.pi * 1/2, math.pi * 1/2),    # ç¬¬2ä¸ªå…³èŠ‚ï¼šÂ±90Â°  (æ¯”ä¹‹å‰æ›´ä¸¥æ ¼)
            (-math.pi * 1/2, math.pi * 1/2),    # ç¬¬3ä¸ªå…³èŠ‚ï¼šÂ±90Â°  (æ¯”ä¹‹å‰æ›´ä¸¥æ ¼)
            (-math.pi * 1/2, math.pi * 1/2),    # ç¬¬4ä¸ªå…³èŠ‚ï¼šÂ±90Â°  (æ¯”ä¹‹å‰æ›´ä¸¥æ ¼)
            (-math.pi * 1/2, math.pi * 1/2),    # ç¬¬5ä¸ªå…³èŠ‚ï¼šÂ±90Â°  (æ¯”ä¹‹å‰æ›´ä¸¥æ ¼)
        ]
        
        # ğŸ”§ ä»é”šç‚¹å¼€å§‹æ„å»ºæœºå™¨äººï¼Œæ¯ä¸ªlinkéƒ½æœ‰æ˜ç¡®çš„ä½ç½®
        current_pos = list(self.anchor_point)  # [x, y]
        
        for i in range(self.num_links):
            length = self.link_lengths[i]
            mass = density * length * 10  # ğŸ”§ å¢åŠ è´¨é‡
            moment = pymunk.moment_for_segment(mass, (0, 0), (length, 0), 8)  # ğŸ”§ å¢åŠ åŠå¾„
            body = pymunk.Body(mass, moment)
            
            # ğŸ”§ è®¾ç½®åˆå§‹ä½ç½®ï¼ˆè®©æœºå™¨äººè‡ªç„¶å‚ç›´ä¸‹å‚ï¼‰
            body.position = current_pos
            body.angle = math.pi/2  # æ‰€æœ‰linkåˆå§‹éƒ½å‚ç›´å‘ä¸‹
            
            # ğŸ”§ åˆ›å»ºå½¢çŠ¶ - å¢åŠ åŠå¾„è®©ç¢°æ’æ›´æ˜æ˜¾
            shape = pymunk.Segment(body, (0, 0), (length, 0), 8)  # åŠå¾„ä»5å¢åŠ åˆ°8
            shape.friction = 0.8  # ğŸ”§ å¢åŠ æ‘©æ“¦åŠ›
            shape.collision_type = i + 1  # ğŸ”§ ä¸ºæ¯ä¸ªlinkè®¾ç½®ä¸åŒçš„ç¢°æ’ç±»å‹
            
            self.space.add(body, shape)
            self.bodies.append(body)
            
            # åˆ›å»ºå…³èŠ‚è¿æ¥
            if i == 0:
                # ğŸ”§ åŸºåº§å…³èŠ‚ï¼šè¿æ¥åˆ°ä¸–ç•Œ
                joint = pymunk.PinJoint(self.space.static_body, body, self.anchor_point, (0, 0))
                joint.collide_bodies = False
                self.space.add(joint)
                self.joints.append(joint)
                
                # ğŸ”§ æ·»åŠ å¼ºåŠ›è§’åº¦é™åˆ¶çº¦æŸ
                if i < len(self.joint_angle_limits):
                    min_angle, max_angle = self.joint_angle_limits[i]
                    limit_joint = pymunk.RotaryLimitJoint(
                        self.space.static_body, body, 
                        min_angle, max_angle
                    )
                    # ğŸ”§ å¢åŠ çº¦æŸçš„åˆšåº¦
                    limit_joint.max_force = 50000  # å¤§å¹…å¢åŠ æœ€å¤§çº¦æŸåŠ›
                    self.space.add(limit_joint)
                    self.joint_limits.append(limit_joint)
                
            else:
                # ğŸ”§ è¿æ¥åˆ°å‰ä¸€ä¸ªlinkçš„æœ«ç«¯
                joint = pymunk.PinJoint(prev_body, body, (self.link_lengths[i-1], 0), (0, 0))
                joint.collide_bodies = False
                self.space.add(joint)
                self.joints.append(joint)
                
                # ğŸ”§ æ·»åŠ ç›¸å¯¹è§’åº¦é™åˆ¶çº¦æŸ
                if i < len(self.joint_angle_limits):
                    min_angle, max_angle = self.joint_angle_limits[i]
                    limit_joint = pymunk.RotaryLimitJoint(
                        prev_body, body, 
                        min_angle, max_angle
                    )
                    # ğŸ”§ å¢åŠ çº¦æŸçš„åˆšåº¦
                    limit_joint.max_force = 50000  # å¤§å¹…å¢åŠ æœ€å¤§çº¦æŸåŠ›
                    self.space.add(limit_joint)
                    self.joint_limits.append(limit_joint)
            
            # ğŸ”§ è®¡ç®—ä¸‹ä¸€ä¸ªlinkçš„èµ·å§‹ä½ç½®ï¼ˆç”¨äºåˆå§‹åŒ–ï¼‰
            if i < self.num_links - 1:
                end_x = current_pos[0] + length * math.cos(math.pi/2)  # å‚ç›´å‘ä¸‹
                end_y = current_pos[1] + length * math.sin(math.pi/2)
                current_pos = [end_x, end_y]
            
            prev_body = body
        
        # ğŸ”§ æ·»åŠ å…³èŠ‚é—´ç¢°æ’æ£€æµ‹ï¼ˆå¯é€‰ - é˜²æ­¢ä¸¥é‡è‡ªç¢°æ’ï¼‰
        self._setup_collision_handlers()

    def _setup_collision_handlers(self):
        """è®¾ç½®å…³èŠ‚é—´ç¢°æ’å¤„ç†"""
        try:
            def collision_handler(arbiter, space, data):
                # å½“ç›¸é‚»å…³èŠ‚ç¢°æ’æ—¶ï¼Œé˜»æ­¢ç©¿é€
                return True  # å…è®¸ç¢°æ’å¤„ç†
            
            # ğŸ”§ åªå¤„ç†éç›¸é‚»å…³èŠ‚çš„ç¢°æ’ï¼ˆç›¸é‚»å…³èŠ‚å…è®¸æ¥è§¦ï¼‰
            for i in range(self.num_links):
                for j in range(i + 2, self.num_links):  # è·³è¿‡ç›¸é‚»å…³èŠ‚
                    try:
                        # å°è¯•ä¸åŒçš„æ–¹æ³•å
                        if hasattr(self.space, 'add_collision_handler'):
                            handler = self.space.add_collision_handler(i + 1, j + 1)
                        elif hasattr(self.space, 'add_wildcard_collision_handler'):
                            handler = self.space.add_wildcard_collision_handler(i + 1)
                        else:
                            # å¦‚æœæ–¹æ³•ä¸å­˜åœ¨ï¼Œè·³è¿‡ç¢°æ’å¤„ç†è®¾ç½®
                            print("âš ï¸ ç¢°æ’å¤„ç†å™¨è®¾ç½®è·³è¿‡ - pymunkç‰ˆæœ¬ä¸å…¼å®¹")
                            return
                        handler.pre_solve = collision_handler
                    except Exception as e:
                        print(f"âš ï¸ è®¾ç½®ç¢°æ’å¤„ç†å™¨å¤±è´¥: {e}")
                        continue
        except Exception as e:
            print(f"âš ï¸ ç¢°æ’å¤„ç†å™¨è®¾ç½®è·³è¿‡: {e}")
            # ä¸å½±å“ä¸»è¦åŠŸèƒ½ï¼Œç»§ç»­è¿è¡Œ

    def _apply_damping(self, body, gravity, damping, dt):
        """åº”ç”¨è½»å¾®çš„é˜»å°¼åŠ›"""
        # ğŸ”§ å¢åŠ é˜»å°¼ï¼Œç‰¹åˆ«æ˜¯è§’é€Ÿåº¦é˜»å°¼
        body.velocity = body.velocity * 0.995  # å¢åŠ çº¿æ€§é˜»å°¼
        body.angular_velocity = body.angular_velocity * 0.99  # å¢åŠ è§’é€Ÿåº¦é˜»å°¼
        # åº”ç”¨é‡åŠ›
        pymunk.Body.update_velocity(body, gravity, damping, dt)

    def reset(self, seed=None, options=None):  # ä¿®å¤ï¼šæ·»åŠ æ­£ç¡®çš„resetæ–¹æ³•
        super().reset(seed=seed)
        self.space.remove(*self.space.bodies, *self.space.shapes, *self.space.constraints)
        self.bodies.clear()
        self.joints.clear()
        self.obstacles.clear()
        
        # ğŸ”§ æ¸…ç†è§’åº¦é™åˆ¶çº¦æŸ
        if hasattr(self, 'joint_limits'):
            self.joint_limits.clear()

        self._create_robot()
        self._create_obstacle()
        observation = self._get_observation()
        info = {}
        if self.gym_api_version == "old":
            return observation
        else:
            return observation, info

    def _get_observation(self):
        """è·å–å½“å‰çŠ¶æ€è§‚å¯Ÿå€¼"""
        obs = []
        for body in self.bodies:
            obs.extend([body.angle, body.angular_velocity])
        
        # è®¡ç®—æœ«ç«¯æ‰§è¡Œå™¨ä½ç½®
        end_effector_pos = self._get_end_effector_position()
        obs.extend(end_effector_pos)
        
        # ğŸ”§ æ·»åŠ ç›®æ ‡ä¿¡æ¯
        obs.extend(self.goal_pos)  # ç›®æ ‡ä½ç½®
        
        # ğŸ”§ æ·»åŠ ç›¸å¯¹ä½ç½®ä¿¡æ¯  
        relative_pos = np.array(self.goal_pos) - np.array(end_effector_pos)
        obs.extend(relative_pos)  # åˆ°ç›®æ ‡çš„ç›¸å¯¹ä½ç½®
        
        # ğŸ”§ æ·»åŠ è·ç¦»ä¿¡æ¯
        distance = np.linalg.norm(relative_pos)
        obs.append(distance)  # åˆ°ç›®æ ‡çš„è·ç¦»
        
        return np.array(obs, dtype=np.float32)

    def _get_end_effector_position(self):
        """è®¡ç®—æœ«ç«¯æ‰§è¡Œå™¨çš„ä½ç½®"""
        if not self.bodies:
            return [0.0, 0.0]
        
        # ä»ç¬¬ä¸€ä¸ªlinkçš„ä½ç½®å¼€å§‹
        pos = np.array(self.bodies[0].position)
        current_angle = 0.0
        
        for i, body in enumerate(self.bodies):
            # ç´¯ç§¯è§’åº¦
            current_angle += body.angle
            length = self.link_lengths[i]
            
            # è®¡ç®—è¿™ä¸ªlinkæœ«ç«¯çš„ä½ç½®
            if i == 0:
                # ç¬¬ä¸€ä¸ªlinkä»å…¶èµ·å§‹ä½ç½®å»¶ä¼¸
                pos = np.array(self.bodies[0].position) + np.array([
                    length * np.cos(current_angle), 
                    length * np.sin(current_angle)
                ])
            else:
                # åç»­linkä»å‰ä¸€ä¸ªlinkçš„æœ«ç«¯å»¶ä¼¸
                pos += np.array([
                    length * np.cos(current_angle), 
                    length * np.sin(current_angle)
                ])
        
        return pos.tolist()
    
    
    def step(self, actions):
        """ä½¿ç”¨ç›´æ¥åŠ›çŸ©æ§åˆ¶ï¼Œç§»é™¤SimpleMotor"""
        actions = np.clip(actions, -self.max_torque, self.max_torque)
        
        # ğŸ”§ ç›´æ¥åº”ç”¨åŠ›çŸ©åˆ°å…³èŠ‚ï¼Œä¸ä½¿ç”¨é©¬è¾¾
        for i, torque in enumerate(actions):
            if i < len(self.bodies):
                body = self.bodies[i]
                # ç›´æ¥è®¾ç½®æ‰­çŸ©
                body.torque = float(torque)

        # ğŸ”§ æ­¥è¿›ç‰©ç†ä»¿çœŸå‰ï¼Œå…ˆæ£€æŸ¥å’Œä¿®æ­£è§’åº¦
        self._enforce_joint_limits_before_step()
        
        self.space.step(self.dt)
        
        # ğŸ”§ æ­¥è¿›åå†æ¬¡å¼ºåˆ¶æ‰§è¡Œè§’åº¦é™åˆ¶
        self._enforce_joint_limits_after_step()
        
        # ğŸ§ª å‡å°‘è¾“å‡ºé¢‘ç‡
        if not hasattr(self, 'step_counter'):
            self.step_counter = 0
        self.step_counter += 1
        
        if self.step_counter % 20 == 0:  # æ¯20æ­¥æ‰“å°ä¸€æ¬¡
            self._print_joint_status()
        
        observation = self._get_observation()
        reward = self._compute_reward()
        terminated = False
        truncated = False
        info = {}

        if self.gym_api_version == "old":
            done = terminated or truncated
            return observation, reward, done, info
        else:
            return observation, reward, terminated, truncated, info

    def _enforce_joint_limits_before_step(self):
        """åœ¨ç‰©ç†æ­¥è¿›å‰å¼ºåˆ¶æ‰§è¡Œè§’åº¦é™åˆ¶"""
        for i, body in enumerate(self.bodies):
            if i < len(self.joint_angle_limits):
                min_angle, max_angle = self.joint_angle_limits[i]
                
                # æ ‡å‡†åŒ–è§’åº¦åˆ° [-Ï€, Ï€]
                angle = body.angle
                while angle > math.pi:
                    angle -= 2 * math.pi
                while angle < -math.pi:
                    angle += 2 * math.pi
                
                # å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œå¼ºåˆ¶è®¾å›èŒƒå›´å†…å¹¶åœæ­¢æ—‹è½¬
                if angle < min_angle:
                    body.angle = min_angle
                    body.angular_velocity = 0
                    body.torque = 0  # ğŸ”§ ä¹Ÿæ¸…é›¶æ‰­çŸ©
                elif angle > max_angle:
                    body.angle = max_angle
                    body.angular_velocity = 0
                    body.torque = 0  # ğŸ”§ ä¹Ÿæ¸…é›¶æ‰­çŸ©

    def _enforce_joint_limits_after_step(self):
        """åœ¨ç‰©ç†æ­¥è¿›åå¼ºåˆ¶æ‰§è¡Œè§’åº¦é™åˆ¶"""
        for i, body in enumerate(self.bodies):
            if i < len(self.joint_angle_limits):
                min_angle, max_angle = self.joint_angle_limits[i]
                
                # æ ‡å‡†åŒ–è§’åº¦åˆ° [-Ï€, Ï€]
                angle = body.angle
                while angle > math.pi:
                    angle -= 2 * math.pi
                while angle < -math.pi:
                    angle += 2 * math.pi
                
                # åŒé‡æ£€æŸ¥ï¼šå¦‚æœä»ç„¶è¶…å‡ºé™åˆ¶
                if angle < min_angle or angle > max_angle:
                    # é™åˆ¶è§’åº¦
                    body.angle = max(min_angle, min(max_angle, angle))
                    # åœæ­¢æ—‹è½¬
                    body.angular_velocity = 0

    def _print_joint_status(self):
        """æ‰“å°å…³èŠ‚çŠ¶æ€ä¿¡æ¯"""
        angles = [math.degrees(body.angle) for body in self.bodies]
        print(f"æ­¥éª¤ {self.step_counter:4d} - å…³èŠ‚è§’åº¦: {[f'{a:7.1f}Â°' for a in angles]}")
        
        # æ£€æŸ¥çº¦æŸæ˜¯å¦è¿˜å­˜åœ¨
        constraints_count = len([c for c in self.space.constraints if hasattr(c, 'min')])
        print(f"    çº¦æŸæ•°é‡: {constraints_count}/{len(self.joint_limits)} (æœŸæœ›{len(self.joint_limits)})")
        
        # æ£€æŸ¥æ˜¯å¦æœ‰è§’åº¦è¶…å‡ºé™åˆ¶ - ä½¿ç”¨æ›´ä¸¥æ ¼çš„é™åˆ¶
        limit_degrees = [(-135, 135), (-90, 90), (-90, 90), (-90, 90), (-90, 90)]
        violations = []
        for i, (angle, (min_limit, max_limit)) in enumerate(zip(angles, limit_degrees)):
            if angle < min_limit or angle > max_limit:
                violations.append(f"å…³èŠ‚{i+1}è¶…é™: {angle:.1f}Â°")
        
        if violations:
            print(f"    âš ï¸  è§’åº¦è¶…é™: {', '.join(violations)}")
        else:
            print(f"    âœ… æ‰€æœ‰å…³èŠ‚è§’åº¦åœ¨é™åˆ¶èŒƒå›´å†…")

    def _compute_reward(self):
        end_effector_pos = np.array(self._get_end_effector_position())
        distance_to_goal = np.linalg.norm(end_effector_pos - self.goal_pos)
        
        # ğŸ”§ æ›´å¼ºçš„è·ç¦»å¥–åŠ±ä¿¡å·
        distance_reward = -distance_to_goal / 50.0  # ä»100.0æ”¹ä¸º50.0ï¼Œå¢å¼ºè·ç¦»æƒ©ç½š
        
        # ğŸ”§ æ·»åŠ è¿›æ­¥å¥–åŠ±
        if not hasattr(self, 'prev_distance'):
            self.prev_distance = distance_to_goal
        
        progress = self.prev_distance - distance_to_goal  # æ­£å€¼è¡¨ç¤ºé è¿‘
        progress_reward = progress * 20.0  # ä»10.0å¢åŠ åˆ°20.0ï¼Œæ›´å¼ºçš„è¿›æ­¥å¥–åŠ±
        
        # ğŸ”§ æ·»åŠ åˆ°è¾¾ç›®æ ‡çš„å·¨å¤§å¥–åŠ±
        if distance_to_goal <= 50.0:  # åœ¨50åƒç´ é˜ˆå€¼å†…
            success_bonus = 100.0  # å¤§çš„æˆåŠŸå¥–åŠ±
        else:
            success_bonus = 0.0
            
        self.prev_distance = distance_to_goal
        
        return distance_reward + progress_reward + success_bonus
    
    def _load_config(self, config_path):
        if config_path is None:
            return {}
        
        # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œå°†å…¶è½¬æ¢ä¸ºç›¸å¯¹äºå½“å‰è„šæœ¬æ–‡ä»¶çš„è·¯å¾„
        if not os.path.isabs(config_path):
            # è·å–å½“å‰è„šæœ¬æ–‡ä»¶æ‰€åœ¨ç›®å½•
            script_dir = os.path.dirname(os.path.abspath(__file__))
            # å°†ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºåŸºäºè„šæœ¬ç›®å½•çš„ç»å¯¹è·¯å¾„
            config_path = os.path.normpath(os.path.join(script_dir, "..", config_path))
        
        print(f"å°è¯•åŠ è½½é…ç½®æ–‡ä»¶: {config_path}")  # è°ƒè¯•ç”¨
        
        try:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            print(f"é”™è¯¯ï¼šé…ç½®æ–‡ä»¶ {config_path} ä¸å­˜åœ¨")
            return {}
        except Exception as e:
            print(f"é”™è¯¯ï¼šåŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
            return {}

    def _create_obstacle(self):
        if "obstacles" not in self.config:
            return
        
        for obs in self.config["obstacles"]:
            if obs["shape"] == "segment":
                p1 = tuple(obs["points"][0])
                p2 = tuple(obs["points"][1])
                shape = pymunk.Segment(self.space.static_body, p1, p2, 3.0)
                shape.friction = 1.0
                shape.color = (0,0,0,255)
                self.space.add(shape)
                self.obstacles.append(shape)

        if "goal" in self.config:
            self.goal_pos = np.array(self.config["goal"]["position"])
            self.goal_radius = self.config["goal"]["radius"]

   

    def render(self):
        if not self.render_mode:
            return
            
        self.screen.fill((255, 255, 255))
        
        # ç»˜åˆ¶ç›®æ ‡ç‚¹
        pygame.draw.circle(self.screen, (255, 0, 0), self.goal_pos.astype(int), 10)
        
        self.space.debug_draw(self.draw_options)
        pygame.display.flip()
        self.clock.tick(60)  # æ§åˆ¶æ¸²æŸ“å¸§ç‡

    def close(self):
        if hasattr(self, 'screen'):
            pygame.quit()

    def get_joint_angles(self):
        """è·å–æ‰€æœ‰å…³èŠ‚çš„å½“å‰è§’åº¦ï¼ˆåº¦æ•°ï¼‰"""
        return [math.degrees(body.angle) for body in self.bodies]

    
if __name__ == "__main__":
    env = Reacher2DEnv(num_links=5, 
                       link_lengths=[80, 50, 30, 20, 50], 
                       render_mode="human",
                       config_path = "configs/reacher_with_zigzag_obstacles.yaml"
                       )

    running = True
    obs= env.reset()  # ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„resetè°ƒç”¨
    step_count = 0
    
    while running and step_count < 30000:  # å¢åŠ åˆ°300æ­¥æµ‹è¯•æ›´ä¸¥æ ¼çš„é™åˆ¶
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # ğŸ§ª ä½¿ç”¨æå¤§çš„åŠ›çŸ©æµ‹è¯•æ–°çš„è§’åº¦é™åˆ¶ç³»ç»Ÿ
        actions = np.random.uniform(-500, 500, size=env.num_links)  # ä½¿ç”¨æ›´å¤§çš„åŠ›çŸ©æµ‹è¯•
        obs, reward, terminated, truncated= env.step(actions)
        env.render()
        step_count += 1

    env.close()
    
    # ğŸ“Š æœ€ç»ˆæ€»ç»“
    print("\n" + "="*60)
    print("ğŸ¯ å¢å¼ºè§’åº¦é™åˆ¶æµ‹è¯•æ€»ç»“:")
    print(f"âœ… æµ‹è¯•æ­¥æ•°: {step_count}")
    print(f"âœ… çº¦æŸæ•°é‡: {len(env.joint_limits)}")
    print(f"âœ… æœ€ç»ˆå…³èŠ‚è§’åº¦: {env.get_joint_angles()}")
    print(f"âœ… æ”¹è¿›çš„è§’åº¦é™åˆ¶ç³»ç»Ÿ:")
    print(f"   - ç§»é™¤äº†SimpleMotor (é¿å…å†²çª)")
    print(f"   - å¢å¼ºäº†RotaryLimitJointçº¦æŸåŠ›")
    print(f"   - æ·»åŠ äº†åŒé‡è§’åº¦å¼ºåˆ¶æ£€æŸ¥")
    print(f"   - å¢åŠ äº†å…³èŠ‚é—´ç¢°æ’æ£€æµ‹")
    print(f"   - ä½¿ç”¨æ›´ä¸¥æ ¼çš„è§’åº¦é™åˆ¶")
    print("="*60)